Я постаралась провести анализ над кодом в моем проекте, который мы делали на Продвинутом курсе PHP. 
Да, мне пока с трудом дается анализ кода. И видимых антипаттернов я не нашла. 
Но я постаралась применить полученные по антипаттернам теоретические знания на моем коде 
с точки зрения, какой антипаттерн мог возникнуть в моем проекте, 
если бы я нарушила какие-то условия. Собственно это я и указала в файле под названием lesson3. 

Если бы я в класс User включила бы создание объектов Name, 
то получился бы длинный запутанный спагетти-код. 

Если бы я наоборот класс User разбила бы на несколько других абстракций, 
т.е. отдельно создание пароля, отдельно создание username, 
то получилось бы излишнее количество уровней абстракции, 
что привело бы к использованию антипаттерна «Лазанья-код» 

Если бы я свойства класса User  $uuid, $name, $username, $hashedPassword назвала бы, 
допустим, как $n, $n-e, $u-name или какими-то необычными аббревиатурами, 
которые были бы непонятны не то, чтобы какому-то другому разработчику, 
но и впоследствии мне самой, то это был бы однозначно антипаттерн «Шифрованный код». 


Если бы мы в класс User добавили полномочия создавать лайк, создавать пост, создавать коммент и т.д. , 
а не делегировали бы это соответствующим другим классам Like, Post, Comment, 
то могли бы сделать из класса User, «божественный объект» согласно одноименному антипаттерну. 


Если бы я придумала класс, допустим, под названием Author, 
который призван только лишь из класса User, получить объект $user  и 
никакой другой функциональности класс Author не выполнял бы, 
то мы бы имели дело с антипаттерном «Полтергейст». 

Если бы в интерфейс  PostsRepositoryInterface  кроме методов save(), get(), getByUsername 
я бы добавила, допустим, метод getCommentToPost, 
то получился бы паттерн «Интерфейсная солянка», 
поскольку слишком много функционала было бы заложено в данный интерфейс. 

